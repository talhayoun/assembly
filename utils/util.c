#include "../headers/util.h"
#include "../headers/macro.h"
#include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

char *trimSpaces(char *value)
{
    char *end;
    while (isspace(*value))
    {
        value++;
    }

    end = value + strlen(value) - 1;
    while (end > value && isspace(*end))
    {
        end--;
    }
    end[1] = '\0';
    return value;
}

char *readLineFromFile(FILE *fptr, char *value)
{
    fgets(value, READ_LINE_LENGTH, fptr);

    /** Removes blank line generated by fgets*/
    removeBlankLine(value);

    /** Removes spaces if any*/
    return trimSpaces(value);
}

void removeBlankLine(char *str)
{
    str[strcspn(str, "\n")] = 0;
}

int findCommand(char *value, cmd *commands)
{
    int i;

    /** Loops commands and finds out if macro name equals one of the commands name*/
    for (i = 0; i < COMMANDS_AMOUNT; i++)
    {
        if (!strcmp(value, commands[i].name))
        {
            /** If equals, throw error and return false*/
            return i;
        }
    }
    return -1;
}

char *findInstruction(char *value, char **instructions)
{
    char *ins = findByValue(value, instructions, INSTRUCTIONS_AMOUNT);
    return ins ? ins : NULL;
}

char *findRegister(char *value, char **registers)
{
    char *reg = findByValue(value, registers, REGISTER_AMOUNT);

    return reg ? reg : NULL;
}

char *findByValue(char *value, char **arr, int length)
{
    int i;
    /** Loops instructions and finds out if macro name equals one of the instructions value*/
    for (i = 0; i < length; i++)
    {
        if (!strcmp(value, arr[i]))
        {
            return arr[i];
        }
    }

    return FALSE;
}

int isEmptyLine(char *str, int showError)
{
    while (*str)
    {
        if (isalpha(*str) || isdigit(*str))
        {
            return FALSE;
        }
        str++;
    }

    if (showError)
    {
        printf("ERROR | Line is empty line | ");
    }
    return TRUE;
}

int isLineAComment(char *str, int printError)
{
    if (*str == COMMENT_SYMBOL)
    {
        if (printError)
            printf("ERROR | Line is a comment |  ");
        return TRUE;
    }
    return FALSE;
}

int validateSingleCommaBetweenOperands(char *value)
{
    int foundComma = 0;
    while (*value)
    {
        if (*value == ',')
        {
            if (foundComma)
            {
                printf("ERROR: Two commas in a row \n");
                return FALSE;
            }

            foundComma = 1;
        }
        else
        {
            foundComma = 0;
        }

        value++;
    }
    return TRUE;
}

int validateLabel(char *label, dataObject data, node *macros)
{
    char *copyLabel = allocateMemoryForChar(strlen(label));

    strcpy(copyLabel, label);

    /** If label doesn't start with alpha, its invalid */
    if (!isalpha(*copyLabel))
    {
        return FALSE;
    }

    while (*copyLabel)
    {
        if (strlen(copyLabel) == 1 && *copyLabel == ':')
        {
            break;
        }

        if (!isalnum(*copyLabel))
        {
            return FALSE;
        }
        copyLabel++;
    }

    free(copyLabel);
    label[strlen(label) - 1] = '\0';

    return !findMacroByName(&macros, label) && findCommand(label, data.commands) == -1 && !findInstruction(label, data.instructions) && !findRegister(label, data.registers);
}

int validateStringSeperatedByCommas(char *arr, int numbersOnly)
{
    int symbol = 0;
    int comma = 0;
    int number = 0;
    int space = 0;
    int special = 0;
    int hashtag = 0;

    arr = trimSpaces(arr);

    if (checkLeadingAndTrailingComma(arr))
    {
        return FALSE;
    }

    /** Loops string character by character*/
    while (*arr)
    {
        while (isspace(*arr))
        {
            /** If there is space inbetween, trim it*/
            arr++;
            space = 1;
        }

        if (numbersOnly && isdigit(*arr))
        {
            /** If found digit, but there was space before and already digit, it means there is a missing comma inbetween*/
            if (space && number && !comma)
            {
                printf("ERROR: Missing comma between numbers \n");
                return FALSE;
            }

            symbol = 0;
            comma = 0;
            number = 1;
            space = 0;
        }
        else if (!numbersOnly && isalnum(*arr))
        {

            if (hashtag && isalpha(*arr))
            {
                printf("ERROR: Invalid, provided alpha characters %c -  %s\n", *arr, arr);
                return FALSE;
            }

            /** If found alphanumeric, but there was space before and already digit, it means there is a missing comma inbetween*/
            if (space && number && !comma)
            {
                printf("ERROR: Missing comma between numbers \n");
                return FALSE;
            }

            symbol = 0;
            comma = 0;
            number = 1;
            space = 0;
            special = 0;
            hashtag = 0;
        }
        else if (*arr == ',')
        {
            /** If last character that was found is comma and now finds comma again, that means two commas in a row*/
            if (comma == 1)
            {
                printf("ERROR: Two commas in between numbers\n");
                return FALSE;
            }
            comma = 1;
            number = 0;
            symbol = 0;
            special = 0;
            hashtag = 0;
            space = 0;
        }
        else if (*arr == '+' || *arr == '-')
        {
            /** If last character was a symbol and now another symbol, thats an error. Cannot have two symbols in a row*/
            if (symbol)
            {
                printf("ERROR: Invalid number, two symbols \n");
                return FALSE;
            }
            if (space && number && !comma)
            {
                printf("ERROR: Missing comma between numbers\n");
                return FALSE;
            }

            symbol = 1;
            space = 0;
        }
        else if (!numbersOnly && (*arr == '#' || *arr == '*'))
        {
            /** If last character was a symbol and now another symbol, thats an error. Cannot have two symbols in a row*/
            if (special || hashtag)
            {
                printf("ERROR: Invalid number, two special symbols \n");
                return FALSE;
            }
            if (space && number && !comma)
            {
                printf("ERROR: Missing comma between numbers\n");
                return FALSE;
            }
            if (*arr == '#')
            {
                hashtag = 1;
            }
            else
            {
                special = 1;
            }
            symbol = 0;
            space = 0;
        }
        else
        {
            printf("ERROR: Invalid number %c \n", *arr);
            return FALSE;
        }
        arr++;
    }

    if (special || hashtag)
    {
        printf("ERROR: Ended with special but no value\n");
        return FALSE;
    }

    return TRUE;
}

int *extractNumbersSeperatedByCommas(char *numbers, int *amount)
{
    int num;
    char *token;
    int *nums = (int *)calloc(0, sizeof(int));
    int i = 0;
    token = strtok(numbers, ",");
    token = trimSpaces(token);

    if (nums == NULL)
    {
        printf("ERROR: Failed to calloc memory location\n");
        return NULL;
    }

    while (token != NULL)
    {
        num = atoi(token);
        nums = realloc(nums, sizeof(int) * ((i) + 1));
        if (nums == NULL)
        {
            printf("ERROR: Failed to allocate memory for nums\n");
            return NULL;
        }
        nums[i] = num;

        i++;
        token = strtok(NULL, ",");
    }

    *amount = i;
    return nums;
}

char **extractOperandsSeperatedByCommas(char *operands, int *amount)
{
    char *token;
    char **ops = (char **)calloc(0, sizeof(char *));
    int i = 0;

    token = strtok(operands, ",");

    if (token == NULL)
    {
        *amount = 0;
        return NULL;
    }

    while (token != NULL)
    {
        token = trimSpaces(token);
        ops[i] = allocateMemoryForChar(strlen(token));
        if (ops == NULL)
        {
            printf("ERROR: Failed to allocate memory for ops\n");
            return NULL;
        }
        strcpy(ops[i], token);

        i++;
        token = strtok(NULL, ",");
    }

    *amount = i;
    return ops;
}

int validateParentheses(char *str)
{

    if (str[0] != '"')
        return FALSE;

    if (str[strlen(str) - 1] != '"')
        return FALSE;

    return TRUE;
}

char *concatString(char *str, char *extension)
{
    char *newFile = allocateMemoryForChar(strlen(str) + strlen(extension));

    strcpy(newFile, str);
    strcat(newFile, extension);

    return newFile;
}

FILE *openFileAndCheckIfSuccess(char *fileName, char *mode)
{
    FILE *fptr = fopen(fileName, mode);

    if (fptr == NULL)
    {
        printf("ERROR: Failed to open file %s\n", fileName);
    }

    return fptr;
}

char *allocateMemoryForChar(int length)
{
    char *newChar = malloc(sizeof(char) * length + 1);
    if (newChar == NULL)
    {
        printf("ERROR: Failed to allocate memory location LENGTH - (%d) \n", sizeof(char) * length + 1);
        exit(1);
    };

    return newChar;
}

int checkLeadingAndTrailingComma(char *str)
{
    /** If starts with comma before number, returns false*/
    if (*str == ',')
    {
        printf("ERROR: Cannot have comma before first number \n");
        return TRUE;
    }

    /** If ends with comma after number, returns false*/
    if (str[strlen(str) - 1] == ',')
    {
        printf("ERROR: Cannot have comma after last number \n");
        return TRUE;
    }

    return FALSE;
}